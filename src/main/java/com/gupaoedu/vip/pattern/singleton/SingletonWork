1、熟练掌握单例模式的常见写法。
2、总结每种单例写法的优、缺点。
  饿汉式单例,它是在类加载的时候就立即初始化，并且创建单例对象

    优点：1.没有加任何的锁、执行效率比较高，
         2.在用户体验上来说，比懒汉式更好
         3.绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题
    缺点：1.类加载的时候就初始化，不管你用还是不用，我都占着空间
          2.浪费了内存

  懒汉式单例
  优点：被外部类调用的时候内部类才会加载。节约内存
  缺点：线程不安全


  静态内部类
  优点：
  这种形式兼顾饿汉式的内存浪费，也兼顾synchronized性能问题
  缺点：反射破坏单例
  解决办法： 现在，我们在其构造方法中做一些限制，一旦出现多
  次重复创建，则直接抛出异常

  注册式单例
  注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标
  识获取实例。注册式单例有两种写法：一种为容器缓存，一种为枚举登记。
  枚举登记：枚举对象不可能被类加载器加载多次，，不能用反射来创建枚举类型。
  枚举式单例也是《Effective Java》书中推荐的一种单例实现写法。在JDK枚举的语法特殊性，以及反射也为枚举保
  驾护航，让枚举式单例成为一种比较优雅的实现。


  容器式写法
  优点：
  适用于创建实例非常多的情况，便于管理。
  缺点：
  但是，是非线程安全的。





3、思考破坏单例模式的方式有哪些？并且归纳总结。
   反射破坏单例。  解决办法：在其构造方法中做一些限制，一旦出现多
            次重复创建，则直接抛出异常

   序列化破坏单例。解决办法：只需要增加readResolve()方法。
     那如果，创建对象的动作发生频率增大，就
     意味着内存分配开销也就随之增大。

4、梳理内部类的执行逻辑，并画出时序图。

   调用构造方法时，外部类Outer被加载，但这时其静态内部类StaticInner却未被加载。直到调用该内部类的静态方法（在分割线以下），StaticInner才被加载。可以做类似的实验验证非静态内部类的情况。
    结论：加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。
